#' simulate assemblages
#'
#' SimData simulates matrixes (as many as
#' requested) using estimated parameters in the list generated by AssemPar.
#'
#' @param paramaters list of parameters estimated by Assempar
#' @param cases number of data sets to be simulated
#' @param n total number of samples to simulate in each site
#' @param sites total number of sites to simulate in each data set
#' @param positive.sp probability of occurrence of a species once it has been
#'   detected in a previos sample. The default is 0.9 for positive, 0.1 for
#'   negative occurrences.
#' @param negative.sp probability of occurrence of a species once it has been
#'   detected in a previos sample. The default is 0.9 for positive, 0.1 for
#'   negative occurrences.
#'
#' @return The function returns an object of class List including all the simulated data sets to be used by DatQuality and SampSD.
#' @export
#'
#' @examples
#' SimData(paramaters, cases, n, sites, positive.sp, negative.sp)
#'
SimData<-function(paramaters, cases, n, sites, positive.sp = 0.9, negative.sp = 0.1){

  library(vegan)

  Par<-paramaters
  n<-n
  sites<-sites
  positive.sp<-positive.sp
  negative.sp<-negative.sp
  N<- n*sites

  #function for simulation
  Simul<-function(paramaters, n, sites, positive.sp, negative.sp){
    mu<-c(rep(NA, Par$Sest))
    mu<-Par$par$fo/Par$n
    Yh<-as.data.frame(matrix(nrow=N, ncol=Par$Sest+2))
    id.n<-rep(seq(1:n), sites)
    id.sites<-rep(1:sites, each=n)
    Yh[,Par$Sest+1]<-id.n
    Yh[,Par$Sest+2]<-as.factor(id.sites)

    ## For species with random spatial distribution
    for (i in 1:Par$Sest){
      for (j in 1:N){
        if (Par$par$Spatial.cor[i]=="random"){
          Yh[j,i]<-rbinom(1,1,mu[i])
        }
      }
    }

    # For positive spatial autoccorrelation
    for (p in 1:sites){
      for (j in 1:N){
        if (p == Yh[j,Par$Sest+2] & Yh[j,Par$Sest+1] == 1){
          for (i in 1:Par$Sest){
            if (Par$par$Spatial.cor[i]=="positive"){
              Yh[j,i]<-rbinom(1,1,mu[i])
            }
          }
        }
      }
    }

    for (p in 1:sites){
      for (j in 1:N){
        if (p == Yh[j,Par$Sest+2] & Yh[j,Par$Sest+1] > 1){
          for (i in 1:Par$Sest){
            if (Par$par$Spatial.cor[i]=="positive" & Yh[j-1,i] == 1){
              Yh[j,i]<-rbinom(1,1, positive.sp)
            }
            if (Par$par$Spatial.cor[i]=="positive" & Yh[j-1,i] == 0){
              Yh[j,i]<-rbinom(1,1,mu[i])
            }
          }
        }
      }
    }
    # For negative spatial autoccorrelation
    for (p in 1:sites){
      for (j in 1:N){
        if (p == Yh[j,Par$Sest+2] & Yh[j,Par$Sest+1] == 1){
          for (i in 1:Par$Sest){
            if (Par$par$Spatial.cor[i]=="negative"){
              Yh[j,i]<-rbinom(1,1,mu[i])
            }
          }
        }
      }
    }

    for (p in 1:sites){
      for (j in 1:N){
        if (p == Yh[j,Par$Sest+2] & Yh[j,Par$Sest+1] > 1){
          for (i in 1:Par$Sest){
            if (Par$par$Spatial.cor[i]=="negative" & Yh[j-1,i] == 1){
              Yh[j,i]<-rbinom(1,1, negative.sp)
            }
            if (Par$par$Spatial.cor[i]=="negative" & Yh[j-1,i] == 0){
              Yh[j,i]<-rbinom(1,1,mu[i])
            }
          }
        }
      }
    }

    # Simulation of abundances
    for (i in 1:Par$Sest){
      for (j in 1:N){
        if (Par$type == "counts" & Yh[j,i]==1){
          if (Par$par$d[i] > 0 & Par$par$prob[i] < 0.05){
            Yh[j,i]<-rnbinom(1, size= Par$par$d[i], mu=Par$par$mean[i])
          }
          if (Par$par$d[i] >= 0 & Par$par$prob[i] > 0.05 |Par$par$d[i] >= 0 & is.na(Par$par$prob[i])){
            Yh[j,i]<-rpois(1, lambda=Par$par$mean[i])
          }
        }
        if (Par$type == "cover" & Yh[j,i]==1){
          Yh[j,i]<-exp(rnorm(1, mean = Par$par$logmean, sd = sqrt(Par$par$logvar)))
        }
      }
    }
    colnames(Yh)<-c(1:Par$Sest, "n", "sites")
    return(Yh)

  }

  simulated.data<-vector("list", cases)
  for (i in 1:cases){
    simulated.data[[i]]<-Simul(paramaters = Par, n = n, sites = sites, positive.sp=positive.sp, negative.sp=negative.sp)
  }
  return(simulated.data)
}
